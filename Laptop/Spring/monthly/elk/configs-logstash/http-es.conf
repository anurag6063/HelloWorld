input { 
	
	http_poller {
    urls => {
      
      test2 => {
        # Supports all options supported by ruby's Manticore HTTP client
        method => get
        url => "https://techdocs-dev.broadcom.com/content/support/en_us/sitemap.xml"
        headers => {
		   Accept => "application/xml"
        }
     }
    }
    request_timeout => 120
    # Supports "cron", "every", "at" and "in" schedules by rufus scheduler
    schedule => { cron => "*/1 * * * * UTC"}
    codec => "plain"
    metadata_target => "message"
	#ssl_certificate_validation => false 
	#ssl => false
    #ssl_certificate_verification => false
	target => "data"
	#ssl => false
  }
}
filter {

	ruby {
	
		init => "	 require 'rubygems'
					 require 'nokogiri'
					 require 'open-uri'
					 require 'openssl'
					 require 'net/http'
				"
				
		code => "
			puts 'Current Time: Start : ' + Time.new.inspect
			
			puts 'title xpath ', event.get('[@version]')
			puts 'title xpath ', event.get('[data][message]')
			
			doc = Nokogiri.XML(event.get('[data][message]'))
			
			# remove namespaces
			doc.remove_namespaces!
			urlset = doc.xpath('//loc')
			
			puts urlset.length
			
			urlset.each_with_index do |(key, value), index|
				#print 'key: #{key}, value: #{value}, index: #{index}\n'
				print 'url is ', urlset[index].text

				url = urlset[index].text
				
				page = Nokogiri::HTML(open(url))
				puts page.class   # => Nokogiri::HTML::Document

				puts (page.css('html').text).size()
			end	
		
		puts 'Current Time: End : ' + Time.new.inspect
		"
	
	} 


#	split {
#			field => "data.message"
#			terminator => "</url>"
#	}

	
#	xml {
#		source => "data.message"
#		target => "xmldata"
#		namespaces => {
#		  "xsl" => "http://www.sitemaps.org/schemas/sitemap/0.9"
#		  "xhtml" => "http://www.w3.org/1999/xhtml"
#		  "xmlns" => "http://www.sitemaps.org/schemas/sitemap/0.9"
#		}
#
#		"remove_namespaces" => true
#
#		#xmlns="http://www.sitemaps.org/schemas/sitemap/0.9
#		store_xml => true
#		suppress_empty => true
#		
#		}
		
		
#	mutate {
#		
#		
#		remove_field => ["data.message"]
#		}


}

output { 
		
	stdout {codec => rubydebug}	
	
	elasticsearch {
			
			# stage
			#hosts => ["10.85.18.37:9200", "10.85.18.38:9200","10.85.18.39:9200" ]
			
			hosts => "10.85.18.204:9200" # qa/dev
			http_compression => true
			
			index => "web_crawled_anurag_v2"
			#document_id => "%{[fileName]}"
			
			user => "elastic"
			password => "elastic123"

		}
}