
input {
	 
	 
	 
	file {
	    
		 #change according to from where we are picking file; in case its related xml make sure to add _relatedxml in the type name.
		
		path => "/tmp/service_cloud/*"
		
		# This will also become the base index name find the right names in the translate filter
		type => "service_cloud" 
		
		 #for a source that's relatex xml put as "relatedxml" else "casedetail"
		 #change according to environment
		add_field => { 
			"file_type" => "relatedxml" 
			"source" => "Service Cloud"
			"sub_category" => "service cloud"
			"url" => "https://casupport-qa.broadcom.com/case/archived?"
		}
		

	
		start_position => "beginning"
		max_open_files => 18000
		close_older => "1 second"
		sincedb_path => "/tmp/since_db/ActivityHistory-2015-01-02-03_09_sep_2"
		file_sort_by => "path"
		codec => multiline {
			pattern => "^"
			what => "next"
			auto_flush_interval => "1"
			max_lines => 50000
		}
		
	}
	
	#  beats {
	# 	host => 'localhost'
	# 	port => 1949
	# 	# This will also become the base index name find the right names in the translate filter
	# 	# THE FIELDS THAT NEEDS TO BE ADDED ARE ALREADY ADDED BY BEATS
	#   }
	  
}


filter {


	  xml {
		source => "message"
		target => "xmldata"
		namespaces => {
		  "xsl" => "http://www.w3.org/1999/XSL/Transform"
		  "xhtml" => "http://www.w3.org/1999/xhtml"
		}
		store_xml => true
		suppress_empty => true
		
		}
		
	if [file_type] == 'casedetail' {
		 translate {
		field => "[type]"
		destination => "subject_field"
		dictionary => {
		  "automic_case_archival" => 'SUBJECT'
		  "knowledge_archival" =>  'Title'
		  "layer7" => 'subject'
		  "nimsoft" => 'subject'
		  "rally_case_archival" => 'subject'
		  "star_case_archival" => 'title'
		  "xceedium" => 'Description'
		  "service_cloud" => "SUBJECT"
		}
		fallback => "subject"
		
	 }
	 
	 translate {
		field => "[type]"
		destination => "caseno_field"
		dictionary => {
		  "automic_case_archival" => 'CASENUMBER'
		  "knowledge_archival" =>  'CASENUMBER'
		  "layer7" => 'casenumber'
		  "nimsoft" => 'casenumber'
		  "rally_case_archival" => 'CASENUMBER'
		  "star_case_archival" => 'contact'
		  "xceedium" => 'Ticket'
		  "service_cloud" => 'CASENUMBER'
		}
		fallback => "casenumber"
		
	 }
	 
	  translate {
		field => "[type]"
		destination => "product_field"
		dictionary => {
		  "automic_case_archival" => 'CAProduct'
		  "knowledge_archival" =>  'Product_Names__c'
		  "layer7" => 'component__c'
		  "nimsoft" => 'product_family__c'
		  "rally_case_archival" => 'CAProduct'
		  "star_case_archival" => 'CAProduct'
		  "xceedium" => 'Product'
		  "service_cloud" => 'CA_PRODUCT_COMPONENT__C'
		}
		fallback => "CAProduct"
		
	 }
	
	}
	
	ruby {
	
		init => "require 'nokogiri'"
		code => "
			if event.get('[file_type]') == 'casedetail'
				doc = Nokogiri.XML(event.get('[message]'))
				
				
				
				# case no 
				caseno = 'string(//'+ event.get('[caseno_field]') +')'
				#puts 'case ', caseno
				
				event.set('case_number',  doc.xpath(caseno) )
									
				puts 'case no is ', doc.xpath(caseno) 
				event.set('fileName', doc.xpath(caseno) )

				# title
				field = event.get('[subject_field]')
				
				path = 'string(//'+field+'/text())'
				#puts 'title xpath: ', doc.xpath(path)
				event.set('title',doc.xpath(path) + '('+ event.get('[fileName]') + ')' )
				
				
				
				# product info
				productname = 'string(//'+ event.get('[product_field]') +')'
				event.set('productname', doc.xpath(productname) )
				
				
				event.set('url', event.get('[url]')+'source='+ event.get('[type]') + '&id=' + event.get('[fileName]') )
				
				if event.get('[type]') == 'nimsoft' 
					
					xml=event.get('[xmldata][Case][0][relatedList]')
					caseNo=event.get('[xmldata][Case][0][fields][0][section][0][casenumber][0][content]')
								
					till=event.get('[xmldata][Case][0][relatedList]').size
					0.upto(till-1) { |x| puts 'element is : ', xml[x], ' replaced val is : ', xml[x].fetch('relatedListURL')[0].replace(xml[x].fetch('relatedListURL')[0].sub('/RelatedXMLs/','/RelatedXMLs/'+caseNo+'_')); }
					
					puts xml
					 
					event.set('[xmldata][Case][0][relatedList]', xml)
				end
				
			else 
				puts 'path of file is: ', event.get('path')
				event.set('fileName', (event.get('path')).split('/').last);

				puts 'its related xml', event.get('[fileName]')
				
				if ['layer7', 'xceedium'].include? event.get('[type]')
					# end has case no
					urlcaseno=(event.get('[fileName]').split('_').last).split('.').first
				else 
					# start has case no
					urlcaseno=event.get('[fileName]').split('_').first
					puts 'case no is ', urlcaseno
				end
				
				puts 'url ' ,  event.get('[url]') , 'source : ', event.get('[type]') , ' id ', urlcaseno
				event.set('url', event.get('[url]')+'source='+ event.get('[type]') + '&id=' + urlcaseno )
				event.set('case_number', urlcaseno )
				
				if event.get('[type]') == 'nimsoft' 
					event.set('fileName', ( (event.get('path')).split('/')[-3] + '_'+ (event.get('path')).split('/')[-1] ) )
				end
				
				# title for related xml
				event.set('title', (event.get('fileName').gsub('.xml', '')));	
			#	event.set('title', (event.get('fileName').gsub('.xml', '')) + '(' +  urlcaseno + ')'  );	
			end


			# new ruby code for service cloud case comments
			event.set('case_number', event.get('[xmldata][RelatedContent][0][Parent][0][CaseNumber][0]'))
			event.set('original_data', event.get('[xmldata][RelatedContent]'))
			if event.get('[type]') == 'service_cloud' 
					
					finalRecords=[];
					arrayRecords=event.get('[xmldata][RelatedContent]') 

					arrayRecords.each_with_index { | data, index | puts  'we have data: #{index} #{data} ', ' index is ', index ; 
					puts 'modified hash', data 

					# deleting all unnecessary attiributes:
					#data=data.delete('type')
					


					data=data.select {|k,v| k == 'casecomments_COMMENTBODY' || k == 'casecomments_ISPUBLISHED'}
					puts 'modified hash', data 
					puts ' : type is ',event.class
					finalRecords.push(data)
					#event.set('[xmldata][RelatedContent][#{}]', data)

					}
					puts 'final data: ', finalRecords;
					event.set('[xmldata][RelatedContent]', finalRecords);
					

			end
	
			
		"	
	}
	
	# only for case details; layer 7 and nimsoft
	
	if [type] == 'layer7' and [file_type] == 'casedetail' {
		translate {
			field => "[productname]"
			destination => "productname"
			dictionary => {
			  "Mobile API Gateway" => 'MOBILE API GATEWAY'
			  "SaaS API Portal" =>  'API MANAGEMENT SAAS'
			}
			fallback => "API GATEWAY"
			
		 }
	}

	if [type] == 'nimsoft' and [file_type] == 'casedetail' {
			translate {
				field => "[productname]"
				destination => "productname"
				dictionary => {
				  "Nimsoft WatchMouse" => 'App Synthetic Monitor'
				  "Nimsoft Service Desk" =>  'Cloud Service Management'
				  "CA Cloud Service Management" => 'Cloud Service Management'
				  "CA Nimsoft Service Desk" => 'Cloud Service Management'
				  "CA Nimsoft Cloud Monitor (fka WatchMouse)" => 'App Synthetic Monitor'
				}
				fallback => "UNIFIED INFRASTRUCTURE MANAGEMENT"
				
			 }
		}	
	
	
	mutate {
		
		rename =>  { "@timestamp" => "updateddatetime"}
		remove_field => ["subject_field" , "message", "caseno_field", "host", "product_field", "path"]
		}
	 
	
	
	
	
}

output { 
		
	stdout {codec => rubydebug}	
	
	elasticsearch {
			
			# stage
			hosts => ["10.85.18.37:9200", "10.85.18.38:9200","10.85.18.39:9200" ]
			
			#hosts => "10.85.18.204:9200" # qa/dev
			http_compression => true
			
			index => "%{[type]}_test_anu_v3"
			document_id => "%{[case_number]}_RelatedList_CaseComments.xml"
			
			user => "elastic"
			password => "elastic123"

		}
		

	}

	
