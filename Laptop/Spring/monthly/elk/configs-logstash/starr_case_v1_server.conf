#"rser:
# for nimosft use only 1 start
# ex "/u001/anurag/files/nimsoft2/*/*.xml" - case detail
#ex : /u001/anurag/files/nimsoft2/*/RelatedXMLs/*.xml - related

# rally:
#       Issue: missing end character. Fix: cd to rally dir; execute: sed command


# common parser v1:



input {

#       # file reader
#       file {
#
#               # change according to from where we are picking file; in case its related xml make sure to add _relatedxml in the type #name.
#
#               path => "E:/casearchival/logstash/files23/*.xml"
#
#               # This will also become the base index name find the right names in the translate filter
#               type => "knowledge_archival"
#
#               # for a source that's relatex xml put as "relatedxml" else "casedetail"
#               # change according to environment
#               add_field => {
#                       "file_type" => "relatedxml"
#                       "source" => "KB Archive"
#                       "sub_category" => "knowledge_case_details"
#                       "url" => "https://casupport-qa.broadcom.com/case/archived?"
#               }


#       TO READ FILE
#               mode => "read"
#               file_completed_action => "log"
#               file_completed_log_path => "/u001/anurag/sincde_db/read_2.txt"


#               start_position => "beginning"
#               max_open_files => 18000
#               close_older => "1 second"
#               sincedb_path => "E:/casearchival/logstash/logstash-6.7.1/since_db/assddd41"
#               file_sort_by => "path"
#               codec => multiline {
#                       pattern => "^"
#                       what => "next"
#                       auto_flush_interval => "1"
#                       max_lines => 50000
#               }
#
#       }


         beats {

                # local
                host => '10.85.17.225'

                # on server
                #host => '10.85.18.207'
                port => 1947
                # THE FIELDS THAT NEEDS TO BE ADDED ARE ALREADY ADDED BY BEATS
          }


#       http {
#               id => "my_http_plugin"
#               host => "10.85.18.207"
#               port => "1113"
#
#               # This will also become the base index name find the right names in the translate filter
#               type => "rally"
#
#               add_field => {
#                       "file_type" => "relatedxml"
#                       "source" => "KB Archive"
#                       "sub_category" => "knowledge_case_details"
#                       "url" => "https://casupport-qa.broadcom.com/case/archived?"
#               }
#
#       }

}


# valid "file_type" : relatedxml and casedetail

# valid "sub_category" -> "type"/sub_category (for KA and Automic)+related_xml/case_detail/email_message_content

# valid "source" names
#"Automic Archive"
#"KB Archive"
#"Layer7 Archive"
#"Nimsoft Archive"
#"Rally Archive"
#"STAR Archive"
#"Xceedium Archive"

# valid "type" names
# "automic_case_archival"
# "knowledge_archival"
# "layer7"
# "nimsoft"
# "rally_case_archival"
# "star_case_archival"
# "xceedium"

# url: can be dev, qa, prod


filter {


 #ONLY FOR BEATS
                mutate {
                        rename =>  { "[log][file][path]" => "[path]" }
                }


# ONLY FOR HTTP READER
#        mutate {
#                       add_field =>  { "path" => "%{[headers][file]}"}
#                 }

          xml {
                source => "message"
                target => "xmldata"
                namespaces => {
                  "xsl" => "http://www.w3.org/1999/XSL/Transform"
                  "xhtml" => "http://www.w3.org/1999/xhtml"
                }
                store_xml => true
                suppress_empty => true

                }

        if [file_type] == 'casedetail' {
                 translate {
                field => "[type]"
                destination => "subject_field"
                dictionary => {
                  "automic_case_archival" => 'SUBJECT'
                  "knowledge_archival" =>  'Title'
                  "layer7" => 'subject'
                  "nimsoft" => 'subject'
                  "rally_case_archival" => 'subject'
                  "star_case_archival" => 'title'
                  "xceedium" => 'Description'
                  "service_cloud" => "SUBJECT"
                }
                fallback => "subject"

         }

         translate {
                field => "[type]"
                destination => "caseno_field"
                dictionary => {
                  "automic_case_archival" => 'CASENUMBER'
                  "knowledge_archival" =>  'CASENUMBER'
                  "layer7" => 'casenumber'
                  "nimsoft" => 'casenumber'
                  "rally_case_archival" => 'CASENUMBER'
                  "star_case_archival" => 'contact'
                  "xceedium" => 'Ticket'
                  "service_cloud" => 'CASENUMBER'
                }
                fallback => "casenumber"

         }

          translate {
                field => "[type]"
                destination => "product_field"
                dictionary => {
                  "automic_case_archival" => 'CAProduct'
                  "knowledge_archival" =>  'Product_Names__c'
                  "layer7" => 'component__c'
                  "nimsoft" => 'product_family__c'
                  "rally_case_archival" => 'CAProduct'
                  "star_case_archival" => 'CAProduct'
                  "xceedium" => 'Product'
                  "service_cloud" => 'CA_PRODUCT_COMPONENT__C'
                }
                fallback => "CAProduct"

         }

        }

        ruby {

                init => "require 'nokogiri'"
                code => "
                        if event.get('[file_type]') == 'casedetail'
                                doc = Nokogiri.XML(event.get('[message]'))



                                # case no
                                caseno = 'string(//'+ event.get('[caseno_field]') +')'
                                #puts 'case ', caseno

                                event.set('case_number',  doc.xpath(caseno) )

                                puts 'case no is ', doc.xpath(caseno)
                                event.set('fileName', doc.xpath(caseno) )

                                # title
                                field = event.get('[subject_field]')

                                path = 'string(//'+field+'/text())'
                                #puts 'title xpath: ', doc.xpath(path)
                                event.set('title',doc.xpath(path) + '('+ event.get('[fileName]') + ')' )



                                # product info
                                productname = 'string(//'+ event.get('[product_field]') +')'
                                event.set('productname', doc.xpath(productname) )


                                event.set('url', event.get('[url]')+'source='+ event.get('[type]') + '&id=' + event.get('[fileName]') )

                                if event.get('[type]') == 'nimsoft'

                                        xml=event.get('[xmldata][Case][0][relatedList]')
                                        caseNo=event.get('[xmldata][Case][0][fields][0][section][0][casenumber][0][content]')

                                        till=event.get('[xmldata][Case][0][relatedList]').size
                                        0.upto(till-1) { |x| puts 'element is : ', xml[x], ' replaced val is : ', xml[x].fetch('relatedListURL')[0].replace(xml[x].fetch('relatedListURL')[0].sub('/RelatedXMLs/','/RelatedXMLs/'+caseNo+'_')); }

                                        puts xml

                                        event.set('[xmldata][Case][0][relatedList]', xml)
                                end

                        else
                                puts 'path of file is: ', event.get('[path]')
                                event.set('path', (event.get('path').gsub('\\', '/')));
                                #puts 'path of file after change is: ', event.get('path')
                                event.set('fileName', (event.get('path')).split('/').last);

                                puts 'its related xml', event.get('[fileName]')

                                if ['layer7', 'xceedium'].include? event.get('[type]')
                                        # end has case no
                                        urlcaseno=(event.get('[fileName]').split('_').last).split('.').first
                                else
                                        # start has case no
                                        urlcaseno=event.get('[fileName]').split('_').first
                                        puts 'case no is ', urlcaseno
                                end

                                puts 'url ' ,  event.get('[url]') , 'source : ', event.get('[type]') , ' id ', urlcaseno
                                event.set('url', event.get('[url]')+'source='+ event.get('[type]') + '&id=' + urlcaseno )
                                event.set('case_number', urlcaseno )
                                if event.get('[type]') == 'nimsoft'
                                        event.set('fileName', ( (event.get('path')).split('/')[-3] + '_'+ (event.get('path')).split('/')[-1] ) )
                                end

                                # title for related xml
                                event.set('title', (event.get('fileName').gsub('.xml', '')));
                        #       event.set('title', (event.get('fileName').gsub('.xml', '')) + '(' +  urlcaseno + ')'  );
                        end


                        #puts event.get('[type]'), ' ' ,  event.get('[file_type]') , ' ',  'path ',  event.get('[path]'), ' ', event.get('[path]').split('\\')[-2]
                        if event.get('[file_type]') == 'casedetail' && event.get('[type]') == 'star_case_archival'

                                 event.set('sub_category',  ( event.get('[type]') + '_' + event.get('[file_type]') + '_'+ event.get('[path]').split('\\')[-2]) )
                        else
                                 event.set('sub_category',  ( event.get('[type]') + '_'+ event.get('[file_type]') + '_'+ event.get('[path]').split('/')[-3]))
                                 # event.set('sub_category', (type +'_'+ file_type+ '_'+path.split('/')[-3]) )
                        end

                 event.set('updateddatetime','2019-04-05T00:00:00.000Z')
                "
        }

        # only for case details; layer 7 and nimsoft

        if [type] == 'layer7' and [file_type] == 'casedetail' {
                translate {
                        field => "[productname]"
                        destination => "productname"
                        dictionary => {
                          "Mobile API Gateway" => 'MOBILE API GATEWAY'
                          "SaaS API Portal" =>  'API MANAGEMENT SAAS'
                        }
                        fallback => "API GATEWAY"

                 }
        }

        if [type] == 'nimsoft' and [file_type] == 'casedetail' {
                        translate {
                                field => "[productname]"
                                destination => "productname"
                                dictionary => {
                                  "Nimsoft WatchMouse" => 'App Synthetic Monitor'
                                  "Nimsoft Service Desk" =>  'Cloud Service Management'
                                  "CA Cloud Service Management" => 'Cloud Service Management'
                                  "CA Nimsoft Service Desk" => 'Cloud Service Management'
                                  "CA Nimsoft Cloud Monitor (fka WatchMouse)" => 'App Synthetic Monitor'
                                }
                                fallback => "UNIFIED INFRASTRUCTURE MANAGEMENT"

                         }
                }


        mutate {

                #rename =>  { "@timestamp" => "updateddatetime"}
                remove_field => ["@timestamp","subject_field" , "message", "caseno_field", "host", "product_field", "log", "path", "ecs", "agent", "tags", "input", ""]
                }



}

output {

        #stdout {codec => rubydebug}



                elasticsearch {

                        # stage
                        hosts => ["10.85.18.37:9200", "10.85.18.38:9200","10.85.18.39:9200" ]

                        #hosts => "10.85.18.204:9200" # qa/dev
                        http_compression => true

                        index => "%{[type]}_part3_v2"
                        document_id => "%{[fileName]}"

                        user => "elastic"
                        password => "elastic123"

                }


        }
